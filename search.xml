<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《软件工程》课程设计</title>
    <url>/2020/10/25/cl-player/</url>
    <content><![CDATA[<p>软工课设验收已过去一周，一拖再拖的总结可算提上日程。从八月份算起，至今已经将近3月矣，这期间参差着海投和奔走多个招聘会的秋招，当然还有各种面经的吊锤，躺废度过的国庆以及论七八糟学习技术栈。老实说，区区一个课设不至于花费如此多的时间和精力于斯，但转念一想，从对Springboot、shiro、Mybatis、Vue、CSS、JS的0基础到写出一个可观像样的前后端项目，也算还满意。</p>
<h1>前言</h1>
<p>如此，这是一篇关于课程设计的<s>博客</s>（也许会写成实验报告，毕竟是第一篇正式写的Blog）。由于本人喜好篮球也较痴迷于波特兰开拓者，于是当初傻傻的定下了&quot;篮球球员管理系统&quot;，现在一想起就觉得™很中二。好吧，这是一款糅合了球员管理、球队管理、赛事管理和赛事数据管理，以及数据图表化分析，当然还有账号管理等。</p>
<p>此篇博客将会阐述本人和组员此次完成的课设的历程，不会有什么深入的技术探讨，也许会有些较二的Bug，所涉及的技术均停留在使用层面。以下是技术栈：</p>
<ul>
<li>Java</li>
<li>Springboot、Mybatis、Shiro</li>
<li>Vue、Element-UI、vue-element-admin、Apache Echarts</li>
<li>MySQL</li>
<li>Git、IDEA、ApiPost、VS Code</li>
</ul>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/silence/player/main.png" alt=""></p>
<h1>计划预想</h1>
<p>按照去年写报告时的设想，此项目最多在一个月内写完包括学习相关的技术栈部分，事实是，我们从学习技术栈到整体完工，将近快2个月，虽然中间参差着其他的糟心事情，但在工期仍是不让人满意的。</p>
<p>因为经常使用网页版的腾讯体育，并且腾讯体育的UI风格也比较年轻化，不论是赛后的赛事数据统计也好，球员个人页或球队主页也好，整体上都是符合我的审美的，所以在一定层度上，我的UI风格有受此影响或有些许模仿。</p>
<h1>学习技术栈</h1>
<h1>设计重来过</h1>
<h2 id="报告复查整理"><a class="header-anchor" href="#报告复查整理">¶</a>报告复查整理</h2>
<h2 id="数据库设计"><a class="header-anchor" href="#数据库设计">¶</a>数据库设计</h2>
<h2 id="系统设计"><a class="header-anchor" href="#系统设计">¶</a>系统设计</h2>
<h2 id="前后端分离设计"><a class="header-anchor" href="#前后端分离设计">¶</a>前后端分离设计</h2>
<h2 id="接口定义分析"><a class="header-anchor" href="#接口定义分析">¶</a>接口定义分析</h2>
<h1>后端</h1>
<h1>前端跟进</h1>
<h1>一些遗憾</h1>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
        <tag>CBA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于java实现简单的邮件发送和读取</title>
    <url>/2020/07/10/email-stmp-pop3-Java/</url>
    <content><![CDATA[<h1>基于java实现简单的邮件发送和读取</h1>
<h1>前言</h1>
<p>这是计算机网络课程的实验课设，使用java socket发送邮件并且不适用java的mail，基于swing图形实现了一些功能，特地以此作为笔记以备日后查阅。</p>
<h3 id="电子邮件概述"><a class="header-anchor" href="#电子邮件概述">¶</a>电子邮件概述</h3>
<p>电子邮件系统具有三个主要组成构件，即用户代理、邮件服务器以及邮件协议。主要的应用层协议就是简单邮件传送协议SMTP(Simple Mail Transfer Protocol)、邮局协议POP3(Post Office Protocol)以及1993年提出的通用互联网邮件扩充MIME(Multipurpose Internet Mail Extensions)。</p>
<p><strong>邮件服务器</strong>是电子邮件基础结构的核心，其功能是发送和接收邮件，同时还向发件人报告邮件传送的结果（已交付、被拒绝、丢失等），按照客户服务器方式工作。</p>
<p>邮件服务器使用两种不同的协议。一种协议用于用户代理向邮件服务器发送邮件或者在邮件服务器之间发送邮件，如本实验中的SMTP；另一种协议用于用户代理从邮件服务器读取邮件，如邮局协议POP3。</p>
<p>**用户代理UA（User Agent）**是用户与电子邮件系统的接口，大多数情况下它就是运行在用户电脑中的一个程序。因此用户代理又称为电子邮件客户端软件。用户代理向用户提供一个友好的接口（目前主要是窗口界面）来发送和接收邮件。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/%E5%9B%BE%E7%89%871.png" alt=""></p>
<h3 id="邮件发送与SMTP协议"><a class="header-anchor" href="#邮件发送与SMTP协议">¶</a>邮件发送与SMTP协议</h3>
<p>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP规定了14条命令和21种应答信息(部分可见参考与附录)。每条命令用几个字母组成，每一种应答信息一百只有一行，有3位数字的代码开始。</p>
<p>通过Windows命令行下的Telnet，可以简单的实现SMTP发送邮件的简单过程。</p>
<p>1.建立TCP连接：telnet <a href="http://smtp.qq.com" target="_blank" rel="noopener">smtp.qq.com</a> 25 &lt;地址,熟知端口&gt;</p>
<p>2.客户端发送HELO命令标识发件人自己的身份，并得到服务器返回的状态</p>
<p>3.客户端AUTH LOGIN登陆，Base64编码用户的邮件地址和密码</p>
<p>4.邮件传送是从MAIL命令开始的，传送邮件的主体</p>
<p>5.以<CR><LF>.<CR><LF>作为邮件内容的结束</p>
<p>6.连接释放QUIT命令</p>
<h4 id="使用telnet发送邮件"><a class="header-anchor" href="#使用telnet发送邮件">¶</a>使用telnet发送邮件</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C:Client(本地客户) S:Server(SMTP服务器）</span></span><br><span class="line"><span class="comment">//以下为命令行对话框</span></span><br><span class="line">C: HELO PINK        		 <span class="comment">// HELO后的内容任意 warn.1</span></span><br><span class="line">S: <span class="number">250</span>-newxmesmtplogicsvrszc7.qq.com<span class="number">-100.77</span><span class="number">.8</span><span class="number">.215</span><span class="number">-30206205</span>           </span><br><span class="line">  <span class="number">250</span>-SIZE <span class="number">73400320</span>     	 <span class="comment">// qq的stmp返回的是三行                                </span></span><br><span class="line">  <span class="number">250</span> OK            	 <span class="comment">//  其他的smtp一般都返回一行</span></span><br><span class="line">C: AUTH LOGIN       	   <span class="comment">//  验证登陆</span></span><br><span class="line">S: <span class="number">334</span> VXNlcm5hbWU6  </span><br><span class="line">C: Base64 of username      <span class="comment">// 输入经过base64加密后的用户名</span></span><br><span class="line">S: <span class="number">334</span> UGFzc3dvcmQ6 </span><br><span class="line">C: Base64 of password      <span class="comment">// 输入经过base64加密后的密码or授权码)</span></span><br><span class="line">S: <span class="number">235</span> Authentication successful </span><br><span class="line">C: MAIL FROM:&lt;youemail&gt;    <span class="comment">// 发件人 warn.2</span></span><br><span class="line">S: <span class="number">250</span> OK</span><br><span class="line">C: RCPT TO:&lt;ReceiverEmail&gt; <span class="comment">// 收件人</span></span><br><span class="line">S: <span class="number">250</span> OK</span><br><span class="line">C: DATA              <span class="comment">// 邮件</span></span><br><span class="line">S: <span class="number">354</span> End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;. <span class="comment">// 以回车换行+ . +回车换行结束</span></span><br><span class="line">C: TO:	</span><br><span class="line">C: SUBJECT:</span><br><span class="line">C:                   <span class="comment">// CRLF 表示以下为邮件内容 warn.3</span></span><br><span class="line">C: ni,hao </span><br><span class="line">C: good bye!</span><br><span class="line">C: .                  <span class="comment">// 表结束</span></span><br><span class="line">S: <span class="number">250</span> OK: queued as.</span><br></pre></td></tr></table></figure>
<p><em><strong>注意(warn)</strong></em> 1.很奇怪的输入问题，输入过程回退可能会返回502 Invalid(见错误码)，输入时需注意。</p>
<p>2.MAIL FROM和RCPT TO命令的格式容易出错，使用&lt;&gt;(虽然很多博客并没有&lt;&gt;，我怀疑他们的是错的)。</p>
<p>3.此处需要有一个CRLF</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/%E5%9B%BE%E7%89%873.png" alt=""></p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/%E5%9B%BE%E7%89%872.png" alt=""></p>
<h3 id="邮件读取与POP3协议"><a class="header-anchor" href="#邮件读取与POP3协议">¶</a>邮件读取与POP3协议</h3>
<p>POP协议是一种用于接收电子邮件的协议，发送端的邮件根据SMTP协议将被转发给一直处于插电状态的POP服务器。客户端再根据POP协议从POP服务器接收对方发来的邮件。在这个过程中，为了防止他人盗窃邮件内容，还要进行用户验证。具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或 MAC。一旦邮件发送到 PC 机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。</p>
<h4 id="使用telnet读取邮件"><a class="header-anchor" href="#使用telnet读取邮件">¶</a>使用telnet读取邮件</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C:Client(本地客户) S:Server(SMTP服务器）</span></span><br><span class="line"><span class="comment">//以下为命令行对话框</span></span><br><span class="line">C:telent pop.qq.com <span class="number">110</span></span><br><span class="line">C: USER username@qq.com</span><br><span class="line">S: +OK           </span><br><span class="line">C: PASS password</span><br><span class="line">S：+OK <span class="number">25</span> message(s) [<span class="number">8521743</span> <span class="keyword">byte</span>(s)]</span><br><span class="line">C: STAT</span><br><span class="line">S: +OK <span class="number">25</span> <span class="number">8521743</span>  <span class="comment">//请求关于邮箱的统计资料25--邮件总数 邮件大小</span></span><br><span class="line">C：RETR  + 获取的邮件序号  <span class="comment">//获取邮寄原文 序号：新邮件&gt;旧邮件</span></span><br><span class="line">S：+OK <span class="number">34176</span> octets <span class="comment">// 邮件大小 </span></span><br><span class="line">S：该邮件的原文</span><br></pre></td></tr></table></figure>
<h3 id="电子邮件的信息格式"><a class="header-anchor" href="#电子邮件的信息格式">¶</a>电子邮件的信息格式</h3>
<p>MIME, 全称为“Multipurpose Internet Mail Extensions”, 比较确切的中文名称为“多用途互联网邮件扩展”。它是当前广泛应用的一种电子邮件技术规范，基本内容定义于RFC 2045-2049。自然，MIME邮件就是符合MIME规范的电子邮件，或者说根据MIME规范编码而成的电子邮件。在MIME出台之前，使用RFC 822只能发送基本的ASCII码文本信息，邮件内容如果要包括二进制文件、声音和动画等，实现起来非常困难。MIME提供了一种可以在邮件中附加多种不同编码文件的方法，弥补了原来的信息格式的不足。</p>
<p>邮件头包含了发件人、收件人、主题、时间、MIME版本、内容的类型、内容的传输编码方式等重要信息。每条信息称为一个域，由域名后加冒号（“ : ”）和信息内容构成，可以是一行，也可以占用多行。域的首行必须顶头写(即左边不能有空白字符（空格和制表符））；续行则必须以空白字符打头，且第一个空白字符不是信息本身固有的，解码时要过滤掉。另外，邮件头中不允许出现空行。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/4.png" alt="MIME电子邮件头部"></p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/5.png" alt="MIME电子邮件段头"></p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/6.png" alt="MIME电子邮件主体格式"></p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/7.png" alt="MIME电子邮件样例"></p>
<p>如果在邮件中要添加附件，必须定义multipart/mixed段；如果存在内嵌资源，至少要定义multipart/related段；如果纯文本与超文本共存，至少要定义multipart/alternative段。其实很容易察觉，MIME邮件就像我们实体信件一样，信封注明了一些信息。</p>
<h1>设计与实现</h1>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/8.png" alt="总体框架"></p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/9.png" alt=""></p>
<h3 id="Java-socket编程使用"><a class="header-anchor" href="#Java-socket编程使用">¶</a>Java socket编程使用</h3>
<p>关于java的socket编程，可以看到大致流程是这样的，在建立socket连接后，问题转变为如何使用smtp和pop协议对流进行操作。在连接过程中通过输入输出流读取和发送指令。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/10.png" alt="java socket"></p>
<h3 id="登陆页LoginPage"><a class="header-anchor" href="#登陆页LoginPage">¶</a>登陆页LoginPage</h3>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/11.png" alt="login"></p>
<p>将登陆功能封装到User类中,使用java的socket连接SMTP服务器，并且捕获socket的未知主机异常(UnknownHostException)、连接异常ConnectException、连接超时异常(SocketTimeoutException)，并且得到socket的输入流和输出流。根据HELO的返回是不是250(不是说没服务器忙于其他)和AUTH LOGIN命令的返回码是不是(235说明用户名密码正确)确定登陆是否成功，然后释放连接。</p>
<h3 id="主页面mainPage"><a class="header-anchor" href="#主页面mainPage">¶</a>主页面mainPage</h3>
<p>此模块绘制页面，主要做一些按钮的监听事件和负责显示文字。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/12.png" alt="main"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JButton sendButton = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line">		sendButton.setIcon(new ImageIcon(smtpPage.class.getResource("/imagine/发送.png")));</span><br><span class="line">		sendButton.setFont(<span class="keyword">new</span> Font(<span class="string">"等线"</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line">		sendButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(isRight(revtextField.getText())) &#123;</span><br><span class="line">					String subject = subjectTextField.getText();   <span class="comment">// 抄送 和 主题 </span></span><br><span class="line">					String body = contentArea.getText(),Message = <span class="keyword">new</span> String(<span class="string">"&lt;html&gt;&lt;h1&gt;&lt;font color='black'&gt;"</span>);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">boolean</span> signal = <span class="keyword">false</span>;            </span><br><span class="line">					<span class="keyword">int</span> Option = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">if</span>(subjectTextField.getText().length()==<span class="number">0</span>) &#123;</span><br><span class="line">						Message += <span class="string">"主题为空, "</span>;</span><br><span class="line">						signal = <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				    <span class="keyword">if</span>(contentArea.getText().length()==<span class="number">0</span>) &#123;</span><br><span class="line">				    	Message += <span class="string">"邮件内容为空, "</span>;</span><br><span class="line">				    	signal = <span class="keyword">true</span>;</span><br><span class="line">				    &#125;</span><br><span class="line">				    <span class="keyword">if</span>(signal)  Option = JOptionPane.showConfirmDialog(<span class="keyword">null</span>,Message+<span class="string">"确定不填写吗？？&lt;/font&gt;&lt;/h1&gt;&lt;/html&gt;"</span>,<span class="string">"提示"</span>,<span class="number">0</span>);</span><br><span class="line">				  <span class="keyword">if</span>(Option == <span class="number">0</span>) &#123;  <span class="comment">// 选择空的内容为Yes</span></span><br><span class="line">					  String showMessage = <span class="keyword">new</span>  String();</span><br><span class="line">					  Mail.setMailContent(revtextField.getText(),subject, body);</span><br><span class="line">					  showMessage = returnConnet(<span class="keyword">new</span> Send(auth).connect(getMail()));</span><br><span class="line">					  JOptionPane.showMessageDialog(<span class="keyword">null</span>,showMessage,<span class="string">"消息"</span>,<span class="number">1</span>);</span><br><span class="line">				  &#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> </span><br><span class="line">				&#123;   <span class="comment">// 用户名不含@</span></span><br><span class="line">					 JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"用户名不正确，请检查重试."</span>,<span class="string">"错误"</span>,<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/13.png" alt="mainPage"></p>
<h3 id="写信页SmtpPage"><a class="header-anchor" href="#写信页SmtpPage">¶</a>写信页SmtpPage</h3>
<p>这部分将实现SMTP发送邮件功能，数据流可以看主体框架得到。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/14.png" alt="smtp"></p>
<p>通过将发送邮件封装成send类，通过图形部分得到收件人、主题、内容、附件；</p>
<p>在send类中实现邮件的发送。监听发送按钮，触发点击时，捕获各个文本域信息传递给send类发送。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">补充</span><br></pre></td></tr></table></figure>
<p>首先，由于已经使用账号登陆成功，所以接下来发送邮件不必去做检验账号和密码处理，但是socket的异仍需要捕获。简单的流程框架就是使用telnet发送邮件的流程。不过需要处理的是：对各个部分的编码、以及带附件以后采用mixed格式，那么将包含几个multipart，分别由于–boundary分割开，在每一个multipart中都将在此声明一个子part-boundary用于在此multipart中分割。另外需要声明此部分内容的文本格式（假如是文本的话），以及编码方式。然后，在下一个multipart就可以类似的加入附件，可参考以下流程图。</p>
<p>对于正常不带附件的邮件，那么只需要在一个part中描述编码的内容即可，当然也可以多个multipart的文本，不过对于实现来说容易，但是在pop解析部分变得异常艰难。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/15.png" alt="smtp"></p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/16.png" alt="smtpPage"></p>
<h3 id="读信页popPage"><a class="header-anchor" href="#读信页popPage">¶</a>读信页popPage</h3>
<p>此模块堪称为最难部分亦是最复杂部分，不亚于写一个编译词法语法分析。</p>
<p>首先由上述实验内容部分可以得到MIME邮件的基本格式，这其中首先要对smtp的命令关键字进行识别，然后在string中截取出文字格式、编码方式、boundary、filename、multipart-type等内容，由于邮件都是以–mainboundary–和<CR><LF>.<CR><LF>结束，可作为一切循环的终止条件，以防进入死循环。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/17.png" alt="pop"></p>
<p>由于各种用户代理之间的差异，无可避免的存在了多种情况，如编码和未编码，编码中又有UTF-8和gb2312、gbk等，有一些是没有双引号”修饰的；未编码可能就相对简单。而其他部分也或多或少存在相似的处理。</p>
<p>截取from的type和codetype代码。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/18.png" alt="pop"></p>
<p>邮件是可以自己给自己发送的，默认附件是自动下载的，如上打开附件没有问题。</p>
<p>尝试着解析其他人发来的邮件，此部分堪称最难，由于各种不同的用户代理采用都是MIME，但是很多细节格式并不一致，比如from、subject、boundary的位置顺序并不是固定的。实话说，解析邮件不亚于一个编译器。</p>
<p>以下解析其他人发来的邮件结果。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/19.png" alt="other"></p>
<p>一封带附件的邮件原文，可以观察boundary和partboundary。</p>
<p><img src="https://pink-1301702299.cos.ap-chengdu.myqcloud.com/blog/email/20.png" alt="other"></p>
<h1>最后</h1>
<p>总体而言，写了还是有些收获的。</p>
<blockquote>
<p>台北盆地最大的哀愁就是  比不来华北平原唱的惆怅</p>
</blockquote>
<p><a href="https://github.com/pinkkmin/SNAKEmail" target="_blank" rel="noopener">github</a></p>
<h1>参考</h1>
<p><a href="https://blog.csdn.net/NEUChords/article/details/92090423" target="_blank" rel="noopener">电子邮件</a></p>
<p><a href="https://serversmtp.com/smtp-error/" target="_blank" rel="noopener">SMTP errors and reply codes</a></p>
<p><a href="https://blog.csdn.net/chenfei_5201213/article/details/10138969" target="_blank" rel="noopener">SMTP错误码/建议解决方法</a></p>
<p><a href="https://www.w3school.com.cn/media/media_mimeref.asp" target="_blank" rel="noopener">MIME 参考手册</a></p>
<p><a href="https://blog.csdn.net/weixin_37958284/article/details/77186279" target="_blank" rel="noopener">电子邮件基本格式（MIME格式）</a></p>
<p><a href="http://cn.voidcc.com/question/p-zxjbxljv-oh.html" target="_blank" rel="noopener">解码的UTF8电子邮件标题</a></p>
<p><a href="http://cn.voidcc.com/question/p-cdwnkfgp-pa.html" target="_blank" rel="noopener">将电子邮件主题从“？UTF-8？…”转换为字符串？</a></p>
<p><a href="https://blog.csdn.net/iteye_18655/article/details/81400129" target="_blank" rel="noopener">Socket收发邮件–SMTP和POP3</a></p>
<p><a href="https://www.cnblogs.com/sdgwc/p/3324368.html" target="_blank" rel="noopener">SMTP邮件传输协议发送邮件和附件</a></p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>计网实验课设</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2>
<h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>月份与星期的来历</title>
    <url>/2020/07/10/testing-month-day/</url>
    <content><![CDATA[<h1>月份</h1>
<p>公历一年有12个月，公历起源于古罗马历法。罗马的英语原本只有10个月，古罗马皇帝决定增加两个月至末尾，后来的凯撒大帝<code>Gaius Julius Caesar</code>将此2月 移至年初，即1、2月，原本的1、2月顺延为3、4月。</p>
<h3 id="January"><a class="header-anchor" href="#January">¶</a>January</h3>
<p>在罗马传说中 ，有一位叫雅努斯（Janus）的守护神，他是罗马人的门神，生有两张脸，一张向前，回首过往，一张向后，眺望未来。雅努斯也是掌管开始和终结的神，罗马人往往会在结婚、出生等场合祭祀这位神祗。雅努斯是天宫的守门人，每天把天空的大门打开，让阳光普照大地；黄昏时就把大门关上，黑夜也随之降临。罗马人把一月称为Januarius(mensis)，蕴含“Janus之月”之意。</p>
<h3 id="February"><a class="header-anchor" href="#February">¶</a>February</h3>
<p>每年的2月初，罗马人都要杀牲饮酒，欢庆菲勃卢姆节。这一天，人们要忏悔自己过去一年的罪过，洗刷自己的灵魂，以祈求神明的饶恕，使自己成为一个贞洁的人。英语2月February，便是由拉丁文 Februar-ius（即菲勃卢姆节）演变而来。</p>
<h3 id="March"><a class="header-anchor" href="#March">¶</a>March</h3>
<p>3月，原是罗马旧历法的1月，新年的开始。凯撒大帝改革历法后，原来的1月变成3月，但罗马人仍然把3月看做是一年的开始。另外，按照传统习惯，3月是每年出征远战的季节。为了纪念战神玛尔斯(宙斯和赫拉的儿子阿瑞斯)，人们便把这位战神的拉丁Mars名字作为3月的月名。</p>
<h3 id="April"><a class="header-anchor" href="#April">¶</a>April</h3>
<p>罗马的4月，正是鲜花初绽，大地回春的美好季节，也是罗马人纪念维纳斯的月份。英文4月April便由拉丁文Aprilis（即开花的日子）演变而来。而拉丁文之所以写成Aprilis，正是来源于希腊爱与美之女神的名字——阿芙罗狄忒Aphrodite（其罗马名维纳斯），她是爱情和女性美的象征，传说正是因为她，世上才有了玫瑰花</p>
<h3 id="May"><a class="header-anchor" href="#May">¶</a>May</h3>
<p>罗马神话中的女神玛雅Maia，专门司管春天和生命。为了纪念这位女神 ，罗马人便用她的名字——拉丁文 Maius命名5月，英文5月May便由这位女神的名字演变而来。</p>
<h3 id="June"><a class="header-anchor" href="#June">¶</a>June</h3>
<p>罗马神话中的朱诺，就是希腊神话中的天后赫拉，她是宙斯的妻子，也是司管婚姻和生育的女神。古罗马人对她十分崇敬，便把6月以她的名字——拉丁文Junius来命名。因为6月是赫拉守护的月份，据说这个月结婚的人都能得到幸福，就有了六月新娘（June Bride）的说法。</p>
<h3 id="July"><a class="header-anchor" href="#July">¶</a>July</h3>
<p>罗马统治者朱里斯·凯撒（Julius Caesar）被刺身亡后，著名的罗马将军安东尼建议将凯撒大帝诞生的7月，用凯撒的名字——拉丁文Julius命名之。这一建议得到了元老院的通过。英语7月July 由此演变而来。</p>
<h3 id="August"><a class="header-anchor" href="#August">¶</a>August</h3>
<p>朱里斯·凯撒（Julius Caesar）死后，由他的甥孙屋大维续任罗马皇帝。为了和凯撒齐名，他也想用自己的名字来命名一个月份。他的生日在9月，但他选定8月。因为他登基后，罗马元老院在8月授予他Augustus（奥古斯都）的尊号。于是，他决定用这个尊号来命名8月。原来8月比7月少一天，为了和凯撒平起平坐，他又决定从2月中抽出一天加在8月上。从此，2月便少了一天。英语8月August便由这位皇帝的拉丁语尊号演变而来。</p>
<h3 id="September"><a class="header-anchor" href="#September">¶</a>September</h3>
<p>旧历的7月，正是凯撒大帝改革历法后的9月，拉丁文 Septem是“7”的意思。虽然历法改革了，但人们仍袭用旧名称来称呼9月。英语9月September，便由此演变而来。</p>
<h3 id="October"><a class="header-anchor" href="#October">¶</a>October</h3>
<p>英语中的十月，来自拉丁文Octo，即“八”的意思，也是根据旧历法来的。</p>
<h3 id="November"><a class="header-anchor" href="#November">¶</a>November</h3>
<p>罗马皇帝奥古斯都和凯撒都有了自己名字命名的月份，罗马市民和元老院要求当时的罗马皇帝梯比里乌斯用其名命名11月。但梯比里乌斯没有同意，他明智地对大家说，如果罗马每个皇帝都用自己的名字来命名月份，那么出现了第13个皇帝怎么办？于是，11月仍然保留着旧称 Novem，即拉丁文“9”的意思。英语11月November便由此演变而来。</p>
<h3 id="December"><a class="header-anchor" href="#December">¶</a>December</h3>
<p>罗马皇帝琉西乌斯要把一年中最后一个月用他情妇的Amagonius的名字来命名，但遭但元老院的反对。于是，12月仍然沿用旧名Decem，即拉丁文“10”的意思。英语12月December，便由此演变而来.</p>
<h1>星期</h1>
<h3 id="Sunday-Sun"><a class="header-anchor" href="#Sunday-Sun">¶</a>Sunday(Sun.)</h3>
<p>Day of the Sun(太阳日，星期日)。是耶酥复活日，因此西方把这一天看作最神圣的日子，称之为“安息日”或“主日”。公元4世纪，在指定罗马历法时，罗马皇帝君士坦丁大帝把这一天定为合法假日，后被世界各国广泛采用。 Sunday 星期日：Sunday在古英文中的意思是sun’s day(属于太阳的日子)。 对基督徒而言, 星期日是「安息日」, 因为耶稣复活的日子是在星期日。约从公元4世纪起，罗马天主教会就将Sunday定为假日，在这一天禁止任何人工作，教徒都得停止一切娱乐活动，上教堂去做礼拜。直到今日, 世界上大多数的国家都以Sunday为星期例假日。</p>
<h3 id="Monday-Mon"><a class="header-anchor" href="#Monday-Mon">¶</a>Monday(Mon.)</h3>
<p>Day of the Moon(月亮日)。在古英语中写作Monandoeg, 即 day of the moon，拉丁语为Lunaedies。 在古罗马神话中，月亮神为太阳神之妻，因此一周中，也应有她一天。 Monday 星期一 ：在古罗马神话中， Monday的意思是moon day(属于月亮的日子), 因为西方人把这一天献给月之女神。古时候西方人相信, 月的盈亏会影响农作物的生长, 也会影响医疗。此外, 尚有所谓的Blue Monday。 Blue是“忧郁”的意思。星期一是一周工作的开始, 没得玩了, 所以心情不好,。不少国家将星期一当作 family washday(家庭洗濯日), 那是由来已久的习俗。</p>
<h3 id="Tuesday-Tues"><a class="header-anchor" href="#Tuesday-Tues">¶</a>Tuesday(Tues.)</h3>
<p>Day of the Mars(火星日)。这一天是为了纪念战神Tyr而由他的名字命名的。古英语中Tyr的名字写作Tiw。Tiwesdoeg的意思是Tiw’s day(战神日)，它是由拉丁语dies Martis(即 day of Mars)翻译而成的。Tyr原是北欧神话里的战神，也是盎格鲁—撒克逊人的神。他用自己的手作诱饵，捉住了狼精，他的手却被狼精咬掉了。为了纪念他这种勇敢的精神，使用他的名字来命名Tuesday这一天。 值得一提的是，星期二Mars在法语中作Mardi。Mardi Gras表示四旬斋前的狂欢节(星期二)，是天主教徒在复活节之前必须的斋戒仪式。斋戒之前当然要大吃大喝一番了，因此这一天又叫Fat Tuesday。Mardi Gras Day是美国最大的嘉年华会，这一持续两周的盛会每年都会在新奥尔良举行，有数百万人参加。</p>
<h3 id="Wednesday-Wed"><a class="header-anchor" href="#Wednesday-Wed">¶</a>Wednesday(Wed.)</h3>
<p>Wednesday在古英文中的意思是Woden’s day。Woden是北欧诸神之父。为制服狼精而牺牲自己一只手的Tyr, 就是他的儿子。Woden领导神族跟巨人族作战, 他曾牺牲自己锐利的右眼, 跟巨人族换取「智能」的甘泉。他也曾深入地层, 从巨人族那里偷取「诗」的美酒。西方人为了追念这位主神, 就根据他的名字创造了Wednesday这个字。Wednesday(Wed.)—Day of the Mercury(水星日)。这一天是以北欧神话中掌管文化、艺术、战争、死亡的神Woden的名字命名的。Woden是战神Thor的父亲;他勇敢地将在宇宙间制造混乱的“混沌”(Chaos)杀死，并将阵亡将士的英灵请到天界，使他们享受天伦之乐。为怀念他，人们用他的名字命名了Wednesday这一天。 Mercury不但是各路神灵的使者，还是商业、旅行及盗窃的守护神。后来，日尔曼民族用他们自己的神Woden(挪威神话里的Odin)取代了墨丘里神，这就是Wednesday的起源。</p>
<h3 id="Thursday"><a class="header-anchor" href="#Thursday">¶</a>Thursday</h3>
<p>Day of Jupiter(木星日)。这一天是用北欧神话中Thor的名字来命名的。Thor是掌管雷电之神(God of Thunder and Lightning)。他常驾驭着由山羊拉的战车奔驰在天际间，风儿飕飕成了闪电，车轮滚滚成了雷鸣。Thursday在古英文中意思是Thor’s day。Thor是北欧神话中的雷神, 经常带着一把大铁锤。相传有一次, 他的大铁锤被一位叫Thrym的巨人偷走了。Thrym 扬言, 除非神族答应把美丽的爱神Freya嫁给他做为交换。然而Freya抵死不从, 于是神族想了一个办法, 由Thor男扮女装穿Freya的衣服, 假装嫁给他, Thrym不疑有诈, 把铁锤交给新娘。于是Thor抢回了自己的武器, 也立即把Thrym 给杀了。</p>
<h3 id="Friday-Fri"><a class="header-anchor" href="#Friday-Fri">¶</a>Friday(Fri.)</h3>
<p>Day of Venus(金星日)。Friday在古英语中写作Frigedoeg。后来挪威人用他们自己的爱神Frigg(Odin的妻子)取代了维纳斯的地位，所以今天的星期五就是Friday了。 Frigga是掌管婚姻的女神。她是Woden之妻，Thor之母。因为以Woden之名命名了Wednesday,以Thor之名命名了Thursday，为了抚慰她本人，便以她的名Frigga命名了Friday。 Friday 星期五：Friday在古英文中意思是Frigg’s day。Frigg是北欧神话中主司婚姻和生育的女神, 也是Woden的妻子。相传她平日身披闪耀白长袍, 住在水晶宫中, 和侍女们一起编织五颜六色的彩云。 对于北欧人而言, 星期五是幸运的日子。然而对基督徒来说却是相反的, 因为耶稣受难日正好是星期五。</p>
<h3 id="Saturday-Sat"><a class="header-anchor" href="#Saturday-Sat">¶</a>Saturday(Sat.)</h3>
<p>Day of Saturn(土星日)。这是一星期中最后一天，它是由掌管农业之神，罗马主神朱庇特的父亲(the god of Agriculture, father of Jupiter)Saturn的名字命名的，也是英语直接用罗马神话中神名来命名星期名称的唯一的一天，其余几天则是以北欧神话中的神名来命名的。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/36421098" target="_blank" rel="noopener">12月份的英文</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/36421098" target="_blank" rel="noopener">12月份的英文来历</a></p>
<p><a href="https://www.douban.com/group/topic/28393940/" target="_blank" rel="noopener">英文星期的来历</a></p>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式原则</title>
    <url>/2020/10/26/design-pattern-principle/</url>
    <content><![CDATA[<p>在写软件工程课设的过程中，我发现随着代码量增多，稍微一修改代码就有“牵一发而动全身”之感（<s>每次看代码都想抽自己</s>），扩展和维护及其困难，恍惚有一种过程式编程的体验。而且在许多功能和类的职责的划分上页十分草率，耦合度相当的高，于是，是时候该看一看设计模式了。</p>
<h2 id="单一职责原则"><a class="header-anchor" href="#单一职责原则">¶</a>单一职责原则</h2>
<blockquote>
<p>Single Responsibility Principle:  a class should have only one reason to change.</p>
<p>一个类，应当只有一个引起它变化的原因；即一个类应该只有一个职责。一个类只负责一项职责。</p>
</blockquote>
<h3 id="intent"><a class="header-anchor" href="#intent">¶</a>intent</h3>
<p>单一职责原则的核心是控制类的粒度大小、将对象解耦、提高内聚性。该原则强调对象不应该承担过多的职责，如果一个对象承担了太多的职责，那么一个职责的变化可能会削弱或抑制这个类实现其他职责的能力；当客户需要对象的某一职责时，不得不将其他不需要的职责包含进来，造成代码冗余。</p>
<h3 id="conclusion"><a class="header-anchor" href="#conclusion">¶</a>conclusion</h3>
<p>The Single Responsibility Principle represents a good way of identifying classes during the design phase of an application and it reminds you to think of all the ways a class can evolve. A good separation of responsibilities is done only when the full picture of how the application should work is well understand.</p>
<p>类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，可维护性提高，变更的风险降低。</p>
<h2 id="接口隔离原则"><a class="header-anchor" href="#接口隔离原则">¶</a>接口隔离原则</h2>
<blockquote>
<p>Interface segregation Principle: Clients should not be forced to depend upon interfaces that they don’t use.</p>
<p>客户端不应该依赖它不需要的接口。</p>
<p>The dependency of one class to another one should depend on the smallest possibleinterface.</p>
<p>类间的依赖关系应该建立在最小的接口上。</p>
</blockquote>
<h3 id="intent-v2"><a class="header-anchor" href="#intent-v2">¶</a>intent</h3>
<p>实例接口Object Interface，java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物所具有的方法特征的描述，仅是一种逻辑上的抽象。</p>
<p>类接口 Class Interface 指在java中使用interface严格定义的接口，如下：</p>
<ul>
<li>一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</li>
<li>不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构，即不要强迫客户使用它们不用的方法，否则这些客户就会面临由于这些不使用的方法的改变所带来的改变。</li>
</ul>
<p>接口隔离原则核心是约束接口、降低类对接口的依赖性。遵循接口隔离原则，可将臃肿的接口细分为粒度较小的接口，预防外来变更的扩散，提高系统的灵活性和可维护性。接口隔离提高了系统的内聚性，减少了对外交互，降低系统的耦合性，如果接口粒度大小定义合理<s>很难把握</s>，能够提高系统的稳定性，接口过多导致数量剧增，粒度大接口少灵活性又会降低，无法提供定制服务，给整体项目带来无法预料的风险。</p>
<h3 id="conclusion-v2"><a class="header-anchor" href="#conclusion-v2">¶</a>conclusion</h3>
<p>If the design is already done fat interfaces can be segregated using the Adapter pattern.</p>
<p>Like every principle Interface Segregation Principle is one principle which require additional time and effort spent to apply it during the design time and increase the complexity of code. But it produce a flexible design. If we are going to apply it more than is necessary it will result a code containing a lot of interfaces with single methods, so applying should be done based on experience and common sense in identifying the areas where extension of code are more likely to happens in the future.</p>
<p>接口隔离和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装思想。单一职责注重的是职责，接口隔离注重的是对借口依赖的隔离；单一职责主要是约束类，针对程序中的实现和细节，接口隔离约束接口，针对抽象和程序整体框架的构建。</p>
<h2 id="依赖倒置原则"><a class="header-anchor" href="#依赖倒置原则">¶</a>依赖倒置原则</h2>
<blockquote>
<p>Dependence Inversion Principle: High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</p>
<p>高层模块不应该依赖低层模块，两者都依赖其抽象； 抽象不依赖细节；细节应该依赖于抽象。</p>
</blockquote>
<h3 id="intent-v3"><a class="header-anchor" href="#intent-v3">¶</a>intent</h3>
<p>依赖倒置核心是面向接口编程，不要面向实现编程。采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性</p>
<ul>
<li>
<p>通过接口传递实现依赖</p>
</li>
<li>
<p>通过构造函数实现依赖传递</p>
</li>
<li>
<p>通过setter方法实现传递</p>
</li>
</ul>
<p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生。</p>
<h3 id="conclusion-v3"><a class="header-anchor" href="#conclusion-v3">¶</a>conclusion</h3>
<p>When this principle is applied it means the high level classes are not working directly with low level classes, they are using interfaces as an abstract layer. In this case instantiation of new low level objects inside the high level classes(if necessary) can not be done using the operator new. Instead, some of the Creational design patterns can be used, such as Factory Method, Abstract Factory, Prototype.</p>
<p>The Template Design Pattern is an example where the DIP principle is applied.</p>
<p>Of course, using this principle implies an increased effort, will result in more classes and interfaces to maintain, in a few words in more complex code, but more flexible. This principle should not be applied blindly for every class or every module. If we have a class functionality that is more likely to remain unchanged in the future there is not need to apply this principle.</p>
<p>底层模块尽量有抽象类或接口，变量的声明类型尽量是抽象类或接口，如此在变量的引用和实际对象间存在一个缓冲层，利于程序的扩展和优化。<strong>任何类都不应该从具体类派生</strong>，尽量不要覆写基类的方法，使用继承时需遵守里氏替换原则。</p>
<h2 id="里氏替换原则"><a class="header-anchor" href="#里氏替换原则">¶</a>里氏替换原则</h2>
<blockquote>
<p>Liskov’s Substitution Principle：Derived types must be completely substitutable for their base types.</p>
<p>1.If for each object o1 of type S there is an object o2 of type T such thatfor all programs P defined in terms of S,the behavior of P is unchangedwhen o1 is substituted for o2 then T is a subtype of S.</p>
<p>如果对一个类型为S的对象o1，都有类型为T的对象o2，使得以S定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T是类型S的子类型。</p>
<p>2.Functions that use pointers or references to base classes must be ableto use objects of derived classes without knowing it.</p>
<p>所有引用基类的地方必须能透明地使用其子类对象。</p>
</blockquote>
<h3 id="intent-v4"><a class="header-anchor" href="#intent-v4">¶</a>intent</h3>
<p>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道父类还是子类；但是反过来则不可以，有子类的地方，父类未必就能适应。在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
<p>在设计模式中体现里氏替换原则的有如下几个模式：</p>
<p>■ 策略模式■ 组合模式■ 代理模式</p>
<h3 id="Conclusion"><a class="header-anchor" href="#Conclusion">¶</a>Conclusion</h3>
<p>This principle is just an extension of the Open Close Principle and it means that we must make sure that new derived classes are extending the base classes without changing their behavior.</p>
<p>里氏替换主要阐述了有关继承的一些原则， 即何时使用继承，何时不该使用继承，里氏替换原则就是继承复用的基础，反映基类与子类之间的关系，是对开闭原则的补充，是实现抽象化的具体步骤的规范。通俗讲，子类可以拓展父类的方法，但不能改变父类原有的功能(尽量不要覆写)。</p>
<h2 id="开闭原则"><a class="header-anchor" href="#开闭原则">¶</a>开闭原则</h2>
<blockquote>
<p>Open Closed Principle ：Software entities like classes, modules and functions should be <strong>open for extension</strong> but <strong>closed for modifications</strong>.</p>
<p>软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
</blockquote>
<h3 id="intent-v5"><a class="header-anchor" href="#intent-v5">¶</a>intent</h3>
<p>开闭原则是<strong>最基础</strong>的原则，起到总的指导作用，其他原则（单一职责、里氏替换、依赖倒置、接口隔离、迪米特法则）都是开闭原则的具体形态，即其他原则都是开闭原则的手段和工具。开闭原则可提高代码的复用性，粒度越小，被复用的可能性越大。</p>
<h3 id="Conclusion-v2"><a class="header-anchor" href="#Conclusion-v2">¶</a>Conclusion</h3>
<p>Like every principle OCP is only a principle. Making a flexible design involves additional time and effort spent for it and it introduce new level of abstraction increasing the complexity of the code. So this principle should be applied in those area which are most likely to be changed.</p>
<p>There are many design patterns that help us to extend code without changing it. For instance the Decorator pattern help us to follow Open Close principle. Also the Factory Method or the Observer pattern might be used to design an application easy to change with minimum changes in the existing code.</p>
<p>通过“抽象约束、封装变化”实现开闭原则， 通过接口或抽象类为软件实体定义一个相对稳定的抽象层，将相同的可变因素封装在相同的具体类中。软件中易变的细节可通过从抽象派生来实现类的拓展，当软件需要发生变化时，只需根据需求重新派生实现类来扩展即可。</p>
<h2 id="迪米特原则"><a class="header-anchor" href="#迪米特原则">¶</a>迪米特原则</h2>
<blockquote>
<p>Demeter Principle：Only talk to your immediate friends；don’t talk to strangers.</p>
<p>只与你直接的朋友们通信，不要跟“陌生人”说话。</p>
</blockquote>
<h3 id="intent-v6"><a class="header-anchor" href="#intent-v6">¶</a>intent</h3>
<p>直接朋友？当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，即与当前对象存在关联、组合或聚合关系，可以直接访问这些对象的方法。</p>
<p>只依赖应该依赖的对象，只暴露应该暴露的对象。迪米特原则的使用能够降低类间的耦合度，提高系统的复用性和扩展性，但是滥用又会造成大量的中介者，从而增加此系统复杂性，使模块间的通信效率降低。</p>
<p>在设计模式中，对迪米特法则进行应用的设计模式有如下两个：■ 外观模式■ 中介者模式</p>
<h3 id="Conclusion-v3"><a class="header-anchor" href="#Conclusion-v3">¶</a>Conclusion</h3>
<ul>
<li>在类的划分上，应该创建弱耦合的类，类与类之间的耦合越弱，越有利于实现可复用的目标。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设为不变类。</li>
<li>在对其他类的引用上，将引用其他对象的次数降至最低。</li>
<li>不暴露属性成员，而选择提供相应的访问器(getter)。</li>
<li>谨慎使用序列化功能（Serializable）。</li>
</ul>
<h2 id="合成复用原则"><a class="header-anchor" href="#合成复用原则">¶</a>合成复用原则</h2>
<p>Composite Resuse Principle</p>
<h3 id="intent-v7"><a class="header-anchor" href="#intent-v7">¶</a>intent</h3>
<p>在软件复用时，尽量优先使用合成、聚合等关联关系来实现，而其次才考虑使用继承关系，使用继承时务必遵循里氏替换原则，合成复用和里式替换相辅相成，都是开闭原则的具体实现规范。</p>
<p>通常类的复用分为继承复用和合成复用，继承复用简单易实现，但会破坏类的封装性，因为继承会将父类的实现细节暴露给子类，父类对子类却是透明的。继承使子类与父类的耦合度变高，父类的实现任何改变都会引起子类的实现发生变化，不利于扩展与维护。继承限制了复用的灵活性，从父类继承而来的实现是静态的，在编译时已经定义，在运行时不可能发生变化。合成复用维持了类的封装性，因为对象的内部细节对新对象是不可见的，新旧类之间的耦合度低，复用的灵活度高，新对象可以动态地引入与成分对象类型相同的对象。</p>
<h3 id="Conclusion-v4"><a class="header-anchor" href="#Conclusion-v4">¶</a>Conclusion</h3>
<p>尽量使用组成、聚合，少用继承。</p>
<h2 id="最后和读了"><a class="header-anchor" href="#最后和读了">¶</a>最后和读了</h2>
<p>开闭原则是总纲，它告诉我们对修改关闭，对扩展开放；里氏替换原则告诉我们不要破坏类的继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一化；接口隔离原则告诉我们在设计接口时要精简单一；迪米特原则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合和聚合关系复用，少用继承复用。</p>
<p>《设计模式之禅》</p>
<p>《软件设计模式》java版</p>
<p>《图解设计模式》</p>
<p><a href="https://www.oodesign.com/" target="_blank" rel="noopener">《oodesign》</a></p>
<blockquote>
<p>End: 向美好看齐，向明天说你好。</p>
</blockquote>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>testing</title>
    <url>/2020/07/09/testing/</url>
    <content><![CDATA[<p>分组转发是网络核心部分的重要功能</p>
<p>路由器是 实现分组交换关键构建，存储和转发</p>
<h6 id="核心部分最核心功能：交换"><a class="header-anchor" href="#核心部分最核心功能：交换">¶</a>核心部分最核心功能：交换</h6>
<p>电话数量增多，使用交换机完成简</p>
<p>分组交换网以 分组 作为数据传输单元 依次发送到服务端</p>
<p>分组首部含有地址（目的地址和原源地址）</p>
<p>分组 独立地选择传输路径</p>
<p>路由器处理分组过程：把收到的分组暂存； 查找转发表；转发</p>
]]></content>
      <categories>
        <category>分类测试</category>
      </categories>
      <tags>
        <tag>testing1</tag>
        <tag>tesing2</tag>
      </tags>
  </entry>
</search>
